### 快速排序算法证明与边界分析

算法证明使用**算法导论**里的**循环不变式**方法



#### 快排模板(以j为分界)

快排属于分治算法，分治算法都有三步：
1. 分成子问题       
2. 递归处理子问题   
3. 子问题合并       
```
void quick_sort(int q[], int l, int r)
{
    //递归的终止情况
    if(l >= r) return;
    
    //第一步：分成子问题
    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while(i < j)
    {
        do i++; while(q[i] < x);
        do j--; while(q[j] > x);
        if(i < j) swap(q[i], q[j]);
    }
    
    //第二步：递归处理子问题
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
    
    //第三步：子问题合并.快排这一步不需要操作，但归并排序的核心在这一步骤
}
```



#### 待证问题

while循环结束后，`q[l..j] <= x`,`q[j+1..r] >= x`



#### 证明

循环不变式：`q[l..i] <= x q[j..r] >= x`
1. 初始化

    ```
    循环开始之前i = l - 1, j = r + 1
    则q[l..i],q[j..r]为空，满足循环不变式
    ```
    
2. 保持

        假设某轮循环开始前循环不变式成立，即q[l..i] <= x, q[j..r] >= x
        执行循环体
            do i++; while(q[i] < x);
            会使得 q[l..i-1] <= x, q[i] >= x
        
            do j--; while(q[j] > x);
            会使得 q[j+1..r] >= x, q[j] <= x
        
            if(i < j) swap(q[i], q[j]);
            会使得 q[l..i] <= x, q[j..r] >= x
        所以，i和j更新之后，下一次循环开始之前，循环不变式依然成立

3. 终止

        循环结束时，i >= j
        正常情况下，按照循环不变式，我们应该会觉得结果已经显然了
        因为j <= i，q[l..i] <= x, q[j..r] >= x
        所以按照j来划分的话，q[l..j] <= x, q[j+1..r] >= x是显然的
        
        可是，最后一轮循环有点特殊，因为最后一轮循环的if语句一定不会执行
        因为最后一轮循环一定满足 i >= j,不然不会跳出while循环的，所以if语句一定不执行
        
        分析：
        由于最后一轮的if语句一定不执行
        所以，只能保证j <= i和q[l..i-1] <= x, q[i] >= x和q[j+1..r] >= x, q[j] <= x
        由q[l..i-1] <= x，j <= i 和 q[j] <= x 可以得到 q[l..j] <= x
        又因为显然q[j+1..r] >= x
        所以，q[l..r]，q[l..j] <= x,q[j+1..r] >= x,问题得证
        
        只有最后一轮循环结束后，循环不变式不成立，其余的循环都是成立的
        但最终要求的问题还是解决了



### 边界情况分析

#### 分析
快排属于**分治算法**，最怕的就是 `n分成0和n，或 n分成n和0`,这会造成**无限划分**



1. 以`j`为划分时，`x`不能选`q[r]` (若以`i`为划分,则`x`不能选`q[l]`)

        关键句子quick_sort(q, l, j), quick_sort(q, j + 1, r);
        由于j是的最小值是l(简单分析一下可以得出),所以q[j+1..r]不会造成无限划分
        但q[l..j](即quick_sort(q, l, j))却可能造成无限划分，因为j可能为r
        
        举例来说，若x选为q[r]，q[l..r-1] < x,
        那么这一轮循环结束时i = r, j = r，显然会造成无限划分
    

2. `do i++; while(q[i] < x)`和`do j--; while(q[j] > x)`不能用`q[i] <= x` 和 `q[j] >= x`

        假设q[l..r]全相同
        则执行完do i++; while(q[i] <= x);之后，i会自增到r+1
        然后继续执行q[i] <= x 判断条件，造成数组下标越界(但这貌似不会报错)
        并且如果之后的q[i] <= x (i > r) 条件也不幸成立，
        就会造成一直循环下去(亲身实验)，造成内存超限(Memory Limit Exceeded)
    

3. `if(i < j) swap(q[i], q[j])`能否使用 `i <= j`

        可以使用if(i <= j) swap(q[i], q[j]);
        因为 i = j 时，交换一下q[i],q[j] 无影响，马上就会跳出循环了
    

4. 最后一句能否改用`quick_sort(q, l, j-1), quick_sort(q, j, r)`作为划分(用`i`做划分时也是同样的道理,) 

        不能
        根据之前的证明，最后一轮循环可以得到这些结论
        j <= i 和 q[l..i-1] <= x, q[i] >= x 和 q[j+1..r] >= x, q[j] <= x
        所以，q[l..j-1] <= x 是显然成立的，
        但quick_sort(q, j, r)中的q[j] 却是 q[j] <= x，这不符合快排的要求
        
        另外一点，注意quick_sort(q, l, j-1), quick_sort(q, j, r)可能会造成无线划分
        当x选为q[l]时会造成无限划分，报错为(MLE),
        如果手动改为 x = q[r],可以避免无限划分
        但是上面所说的q[j] <= x 的问题依然不能解决，这会造成 WA (Wrong Answer)



##### 顺带一提用`i`做划分时的模板

```
void quick_sort(int q[], int l, int r)
{
    if(l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r + 1 >> 1];
    //注意是向上取整,因为向下取整可能使得x取到q[l]
    while(i < j)
    {
        do i++; while(q[i] < x);
        do j--; while(q[j] > x);
        if(i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, i - 1), quick_sort(q, i, r);
    //不用q[l..i],q[i+1..r]划分的道理和分析4中j的情况一样
}
```